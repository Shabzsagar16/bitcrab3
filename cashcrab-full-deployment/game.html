<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
    <!-- Primary Meta Tags -->
    <title>Bitcrab Runner Game - Play Now! | Bitcrab ($CRAB)</title>
    <meta name="title" content="Bitcrab Runner Game - Play Now! | Bitcrab ($CRAB)" />
    <meta name="description" content="Play the official Bitcrab 3-Lane Runner game! Collect shells, avoid urchins, and compete for high scores. Free to play browser game." />
    <meta name="keywords" content="Bitcrab game, runner game, browser game, $CRAB token, Solana game, free game" />
    <meta name="author" content="Bitcrab Team" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="https://bitcrab.io/game" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://bitcrab.io/game" />
    <meta property="og:title" content="Bitcrab Runner Game - Play Now!" />
    <meta property="og:description" content="Play the official Bitcrab 3-Lane Runner game! Collect shells, avoid urchins, and compete for high scores." />
    <meta property="og:image" content="https://bitcrab.io/assets/img/bitcrab.png" />
    <meta property="og:image:alt" content="Bitcrab Runner Game Screenshot" />
    <meta property="og:site_name" content="Bitcrab" />
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://bitcrab.io/game" />
    <meta property="twitter:title" content="Bitcrab Runner Game - Play Now!" />
    <meta property="twitter:description" content="Play the official Bitcrab 3-Lane Runner game! Collect shells, avoid urchins, and compete for high scores." />
    <meta property="twitter:image" content="https://bitcrab.io/assets/img/bitcrab.png" />
    <meta property="twitter:creator" content="@0x_bitcrab" />
    
    <!-- Favicons -->
    <link rel="icon" type="image/png" href="/assets/img/bitcrab.png" />
    <link rel="apple-touch-icon" href="/assets/img/bitcrab.png" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    
    <link rel="stylesheet" href="/css/styles.css" />
  </head>

  <body>
    <main id="game">
      <header class="site-header">
        <a class="brand" href="/" aria-label="Bitcrab home">
          <picture class="brand__img">
            <source srcSet="/assets/img/bitcrab.png" type="image/png" />
            <img src="/assets/svg/logo.svg" alt="Bitcrab logo" width="36" height="36" />
          </picture>
          <span>$CRAB</span>
        </a>
        <nav class="nav" aria-label="Main">
          <ul class="nav__menu">
            <li><a href="/">Home</a></li>
            <li><a href="#how-to-play">How to play</a></li>
          </ul>
        </nav>
      </header>

      <section class="section section--sand">
        <div class="container">
          <h1>Bitcrab 3‚ÄëLane Runner</h1>
          <p id="how-to-play">Swipe Up/Down or use Arrow/W/S to change lanes. Collect shells, avoid urchins. P to pause, R to restart.</p>
        </div>
      </section>

      <section class="section">
        <div class="container">
          <!-- Simple HTML5 Canvas Game -->
          <div class="game-wrap">
            <canvas id="gameCanvas" width="960" height="540" aria-label="Bitcrab runner game canvas"></canvas>
            <div class="game-ui">
              <div class="game-ui__left">
                <button class="btn btn--ghost" id="pauseBtn" aria-label="Pause game">Pause</button>
                <button class="btn btn--primary" id="restartBtn">Restart</button>
              </div>
            </div>
            <div class="game-loading" id="gameLoading">Loading assets‚Ä¶</div>
            <div class="game-hint" role="note">
              Swipe Up/Down or use Arrow/W/S to change lanes. Collect shells, avoid urchins. 
              Power-ups: Magnet (auto-attract), Shield (one hit). Combos boost score. P to pause, R to restart.
            </div>
          </div>
        </div>
      </section>

      <footer class="site-footer">
        <div class="container">
          <div class="foot__brand">
            <picture class="brand__img">
              <source srcSet="/assets/img/bitcrab.png" type="image/png" />
              <img src="/assets/svg/logo.svg" alt="Bitcrab logo" width="28" height="28" />
            </picture>
            <strong>$CRAB</strong>
          </div>
          <div class="foot__links">
            <a href="/">Home</a>
            <a href="/game">Game</a>
            <a class="social" href="https://twitter.com/0x_bitcrab" target="_blank" rel="noopener noreferrer" aria-label="Twitter"><img src="/assets/svg/x.svg" alt="Twitter icon" width="22" height="22"/></a>
            <a class="social" href="https://t.me/bitcrab0x" target="_blank" rel="noopener noreferrer" aria-label="Telegram"><img src="/assets/svg/telegram.svg" alt="Telegram icon" width="22" height="22"/></a>
          </div>
          <div class="foot__copy">¬© <span id="year"></span> Bitcrab. Made with ü¶Ä + üèñ</div>
        </div>
      </footer>
    </main>

    <!-- Game JavaScript -->
    <script>
      // Simple 3-Lane Runner Game for Static HTML
      class BitcrabRunner {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.sprites = {};
          this.loaded = false;
          this.paused = false;
          this.gameOver = false;
          
          // Game state
          this.player = { x: 180, y: 0, w: 90, h: 90, lane: 1, targetY: 0 };
          this.speed = 260;
          this.obstacles = [];
          this.pickups = [];
          this.powerups = [];
          this.lanes = [];
          this.spawnTimer = 0;
          this.powerSpawnTimer = 6;
          this.bgShift = 0;
          
          // UI state
          this.lives = 4;
          this.shells = 0;
          this.score = 0;
          this.best = 0;
          this.combo = { count: 0, until: 0 };
          this.magnetUntil = 0;
          this.shieldCharges = 0;
          this.invUntil = 0;
          this.countdown = 3;
          
          this.keys = {};
          this.laneChange = 0;
          this.touchStart = null;
          
          this.init();
        }
        
        async init() {
          // Load best score from localStorage
          try {
            const saved = localStorage.getItem('bitcrab_best');
            if (saved) this.best = Math.max(0, Number(saved) || 0);
          } catch {}
          
          // Load sprites
          await this.loadSprites();
          this.loaded = true;
          document.getElementById('gameLoading').style.display = 'none';
          
          this.resize();
          this.setupEvents();
          this.gameLoop();
        }
        
        async loadSprites() {
          const loadImg = (src) => new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
          });
          
          try {
            this.sprites.crab = await loadImg('/assets/img/bitcrab.png');
            this.sprites.shell = await loadImg('/assets/svg/shell.svg');
            this.sprites.palm = await loadImg('/assets/svg/palm.svg');
            this.sprites.wave = await loadImg('/assets/svg/wave.svg');
          } catch (e) {
            console.log('Some sprites failed to load, using fallbacks');
          }
        }
        
        resize() {
          const rect = this.canvas.parentElement.getBoundingClientRect();
          const maxW = Math.min(1100, rect.width);
          const aspect = 16 / 9;
          const w = Math.round(maxW);
          const h = Math.round(w / aspect);
          
          this.canvas.width = w;
          this.canvas.height = h;
          this.w = w;
          this.h = h;
          this.ground = Math.round(h - 96);
          
          // Calculate three lanes
          const top = Math.max(120, this.ground - 140);
          const mid = Math.max(70, this.ground - 70);
          const bot = this.ground;
          this.lanes = [top, mid, bot];
          
          if (this.player.lane < 0 || this.player.lane > 2) this.player.lane = 1;
          this.player.targetY = this.lanes[this.player.lane];
          if (this.player.y === 0) this.player.y = this.player.targetY;
        }
        
        setupEvents() {
          // Keyboard
          document.addEventListener('keydown', (e) => {
            this.keys[e.key] = true;
            if (e.key === 'p' || e.key === 'P') this.togglePause();
            if (e.key === 'r' || e.key === 'R') this.restart();
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') this.laneChange -= 1;
            if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') this.laneChange += 1;
          });
          
          document.addEventListener('keyup', (e) => {
            this.keys[e.key] = false;
          });
          
          // Touch/mouse
          this.canvas.addEventListener('pointerdown', (e) => {
            this.touchStart = { x: e.clientX, y: e.clientY, t: performance.now() };
          });
          
          this.canvas.addEventListener('pointerup', (e) => {
            if (!this.touchStart) return;
            const dx = e.clientX - this.touchStart.x;
            const dy = e.clientY - this.touchStart.y;
            const adx = Math.abs(dx), ady = Math.abs(dy);
            
            if (ady > adx && ady > 24) {
              if (dy < 0) { // swipe up
                this.changeLane(-1);
              } else { // swipe down
                this.changeLane(1);
              }
            }
            this.touchStart = null;
          });
          
          // UI buttons
          document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
          document.getElementById('restartBtn').addEventListener('click', () => this.restart());
          
          // Resize
          window.addEventListener('resize', () => this.resize());
        }
        
        changeLane(direction) {
          const next = Math.max(0, Math.min(2, this.player.lane + direction));
          if (next !== this.player.lane) {
            this.player.lane = next;
            this.player.targetY = this.lanes[this.player.lane];
          }
        }
        
        togglePause() {
          this.paused = !this.paused;
          document.getElementById('pauseBtn').textContent = this.paused ? 'Resume' : 'Pause';
        }
        
        restart() {
          this.obstacles = [];
          this.pickups = [];
          this.powerups = [];
          this.speed = 260;
          this.spawnTimer = 0;
          this.powerSpawnTimer = 6;
          this.player.lane = 1;
          this.player.targetY = this.lanes[this.player.lane];
          this.player.y = this.player.targetY;
          this.score = 0;
          this.combo = { count: 0, until: 0 };
          this.magnetUntil = 0;
          this.shieldCharges = 0;
          this.countdown = 3;
          this.invUntil = 0;
          this.lives = 4;
          this.shells = 0;
          this.gameOver = false;
          this.paused = false;
          document.getElementById('pauseBtn').textContent = 'Pause';
        }
        
        update(dt) {
          if (this.paused || this.gameOver) return;
          
          // Countdown
          if (this.countdown > 0) {
            this.countdown = Math.max(0, this.countdown - dt);
            return;
          }
          
          // Speed up over time
          this.speed += 0.015 * dt * 60;
          this.bgShift += this.speed * dt;
          
          // Handle lane changes
          if (this.laneChange !== 0) {
            this.changeLane(this.laneChange > 0 ? 1 : -1);
            this.laneChange = 0;
          }
          
          // Move player to target lane
          this.player.y += (this.player.targetY - this.player.y) * 0.2 * 60 * dt;
          
          // Spawn entities
          this.spawnTimer -= dt;
          if (this.spawnTimer <= 0) {
            this.spawn();
            this.spawnTimer = Math.max(0.5, 0.9 - Math.min(0.5, (this.speed - 300) / 400));
          }
          
          this.powerSpawnTimer -= dt;
          if (this.powerSpawnTimer <= 0) {
            this.spawnPowerup();
            this.powerSpawnTimer = 8 + Math.random() * 6;
          }
          
          // Update entities
          this.updateEntities(dt);
          
          // Check collisions
          this.checkCollisions();
          
          // Check game over
          if (this.lives <= 0) {
            this.gameOver = true;
          }
        }
        
        spawn() {
          const good = Math.random() < 0.7;
          const lane = Math.floor(Math.random() * 3);
          const x = this.w + 30;
          const y = good ? this.lanes[lane] - 50 : this.lanes[lane] - 16;
          const vx = -this.speed;
          const r = good ? 16 : 14;
          
          if (good) {
            this.pickups.push({ x, y, r, vx });
          } else {
            this.obstacles.push({ x, y, r, vx });
          }
        }
        
        spawnPowerup() {
          const lane = Math.floor(Math.random() * 3);
          const x = this.w + 40;
          const y = this.lanes[lane] - 44;
          const vx = -this.speed * 0.95;
          const type = Math.random() < 0.5 ? 'magnet' : 'shield';
          this.powerups.push({ x, y, r: 18, vx, type });
        }
        
        updateEntities(dt) {
          const now = performance.now();
          
          // Pickups
          for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            p.x += p.vx * dt;
            
            // Magnet effect
            if (this.magnetUntil > now) {
              const dx = this.player.x - p.x;
              const dy = this.player.y - p.y;
              const dist = Math.hypot(dx, dy);
              const radius = 220;
              if (dist < radius) {
                const pull = 900 * dt * (1 - dist / radius);
                p.x += (dx / (dist || 1)) * pull;
                p.y += (dy / (dist || 1)) * pull * 0.35;
              }
            }
            
            if (p.x < -40) {
              this.pickups.splice(i, 1);
            }
          }
          
          // Obstacles
          for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const o = this.obstacles[i];
            o.x += o.vx * dt;
            if (o.x < -40) {
              this.obstacles.splice(i, 1);
            }
          }
          
          // Powerups
          for (let i = this.powerups.length - 1; i >= 0; i--) {
            const u = this.powerups[i];
            u.x += u.vx * dt;
            if (u.x < -40) {
              this.powerups.splice(i, 1);
            }
          }
        }
        
        checkCollisions() {
          const now = performance.now();
          const playerRect = {
            x: this.player.x - this.player.w / 2,
            y: this.player.y - this.player.h,
            w: this.player.w,
            h: this.player.h
          };
          
          // Pickups
          for (let i = this.pickups.length - 1; i >= 0; i--) {
            const p = this.pickups[i];
            if (this.collides(playerRect, p)) {
              this.pickups.splice(i, 1);
              this.shells++;
              
              // Combo scoring
              const comboWindow = 1200;
              if (now < this.combo.until) {
                this.combo.count += 1;
              } else {
                this.combo.count = 1;
              }
              this.combo.until = now + comboWindow;
              
              const mult = 1 + Math.min(4, Math.floor((this.combo.count - 1) / 3));
              this.score += 1 * mult;
              
              if (this.score > this.best) {
                this.best = this.score;
                try {
                  localStorage.setItem('bitcrab_best', String(this.best));
                } catch {}
              }
            }
          }
          
          // Powerups
          for (let i = this.powerups.length - 1; i >= 0; i--) {
            const u = this.powerups[i];
            if (this.collides(playerRect, u)) {
              if (u.type === 'magnet') {
                this.magnetUntil = performance.now() + 6000;
              } else if (u.type === 'shield') {
                this.shieldCharges = Math.min(1, this.shieldCharges + 1);
              }
              this.powerups.splice(i, 1);
            }
          }
          
          // Obstacles
          if (now > this.invUntil) {
            for (let i = this.obstacles.length - 1; i >= 0; i--) {
              const o = this.obstacles[i];
              if (this.collides(playerRect, o)) {
                if (this.shieldCharges > 0) {
                  this.shieldCharges -= 1;
                  this.invUntil = now + 800;
                } else {
                  this.invUntil = now + 1200;
                  this.lives -= 1;
                }
                this.obstacles.splice(i, 1);
                break;
              }
            }
          }
        }
        
        collides(rect, circle) {
          const nearestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
          const nearestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));
          const dx = circle.x - nearestX;
          const dy = circle.y - nearestY;
          return dx * dx + dy * dy <= circle.r * circle.r;
        }
        
        draw() {
          this.ctx.clearRect(0, 0, this.w, this.h);
          
          // Background
          this.drawBackground();
          
          // Entities
          this.drawEntities();
          
          // Player
          this.drawPlayer();
          
          // HUD
          this.drawHUD();
          
          // Overlays
          if (this.gameOver) {
            this.drawGameOver();
          } else if (this.countdown > 0) {
            this.drawCountdown();
          }
        }
        
        drawBackground() {
          // Sky gradient
          const grad = this.ctx.createLinearGradient(0, 0, 0, this.h);
          grad.addColorStop(0, '#9bdcf9');
          grad.addColorStop(0.6, '#6cc4f1');
          grad.addColorStop(1, '#f8e3b0');
          this.ctx.fillStyle = grad;
          this.ctx.fillRect(0, 0, this.w, this.h);
          
          // Sun
          const sunX = this.w * 0.12, sunY = this.h * 0.18, sunR = 46;
          this.ctx.fillStyle = '#ffed96';
          this.ctx.beginPath();
          this.ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
          this.ctx.fill();
          
          // Ground
          this.ctx.fillStyle = '#f1dda9';
          this.ctx.fillRect(0, this.ground + 24, this.w, this.h - (this.ground + 24));
        }
        
        drawEntities() {
          // Pickups (shells)
          this.ctx.fillStyle = '#ffd166';
          for (const p of this.pickups) {
            if (p.x < -40) continue;
            if (this.sprites.shell) {
              this.ctx.drawImage(this.sprites.shell, p.x - p.r, p.y - p.r, p.r * 2, p.r * 2);
            } else {
              this.ctx.beginPath();
              this.ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
              this.ctx.fill();
            }
          }
          
          // Obstacles (urchins)
          this.ctx.fillStyle = '#2b7a84';
          for (const o of this.obstacles) {
            if (o.x < -40) continue;
            this.ctx.beginPath();
            this.ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Spikes
            this.ctx.strokeStyle = '#06363f';
            this.ctx.lineWidth = 2;
            for (let a = 0; a < 8; a++) {
              const ang = (a / 8) * Math.PI * 2;
              this.ctx.beginPath();
              this.ctx.moveTo(o.x + Math.cos(ang) * (o.r - 2), o.y + Math.sin(ang) * (o.r - 2));
              this.ctx.lineTo(o.x + Math.cos(ang) * (o.r + 6), o.y + Math.sin(ang) * (o.r + 6));
              this.ctx.stroke();
            }
          }
          
          // Powerups
          this.ctx.fillStyle = '#ffd166';
          for (const u of this.powerups) {
            if (u.x < -40) continue;
            this.ctx.beginPath();
            this.ctx.arc(u.x, u.y, u.r, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Icon
            this.ctx.fillStyle = '#2a1e02';
            this.ctx.font = '16px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(u.type === 'magnet' ? 'M' : 'S', u.x, u.y + 5);
          }
        }
        
        drawPlayer() {
          const { x, y, w, h } = this.player;
          if (this.sprites.crab) {
            this.ctx.drawImage(this.sprites.crab, x - w / 2, y - h, w, h);
          } else {
            this.ctx.fillStyle = '#ef6b4a';
            this.ctx.fillRect(x - w / 2, y - h, w, h);
          }
        }
        
        drawHUD() {
          const panelW = 210;
          const panelX = this.w - panelW - 10;
          
          // Panel background
          this.ctx.fillStyle = 'rgba(0,0,0,.35)';
          this.ctx.fillRect(panelX, 10, panelW, 70);
          
          // Text
          this.ctx.fillStyle = '#fff';
          this.ctx.font = '700 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          this.ctx.textAlign = 'start';
          this.ctx.fillText(`Speed: ${Math.round(this.speed)}`, panelX + 10, 26);
          this.ctx.fillText(`Shells: ${this.shells}`, panelX + 10, 46);
          this.ctx.fillText(`Lives: ${this.lives}`, panelX + 10, 66);
          
          this.ctx.textAlign = 'end';
          this.ctx.fillText(`Score: ${Math.floor(this.score)}`, panelX + panelW - 10, 26);
          this.ctx.fillText(`Best: ${Math.floor(this.best)}`, panelX + panelW - 10, 46);
          
          // Combo
          if (performance.now() < this.combo.until && this.combo.count > 1) {
            const mult = 1 + Math.min(4, Math.floor((this.combo.count - 1) / 3));
            this.ctx.fillStyle = '#ffd166';
            this.ctx.textAlign = 'center';
            this.ctx.font = '800 18px system-ui';
            this.ctx.fillText(`Combo x${mult}`, panelX + panelW / 2, 86);
          }
        }
        
        drawGameOver() {
          this.ctx.fillStyle = 'rgba(0,0,0,.55)';
          this.ctx.fillRect(0, 0, this.w, this.h);
          
          this.ctx.fillStyle = '#fff';
          this.ctx.textAlign = 'center';
          this.ctx.font = '800 32px Fredoka, system-ui';
          this.ctx.fillText('Game Over', this.w / 2, this.h / 2 - 10);
          
          this.ctx.font = '500 16px system-ui';
          this.ctx.fillText('Press R to Restart', this.w / 2, this.h / 2 + 20);
        }
        
        drawCountdown() {
          this.ctx.fillStyle = 'rgba(0,0,0,.35)';
          this.ctx.fillRect(0, 0, this.w, this.h);
          
          this.ctx.fillStyle = '#fff';
          this.ctx.textAlign = 'center';
          this.ctx.font = '800 48px Fredoka, system-ui';
          const n = Math.ceil(this.countdown);
          this.ctx.fillText(String(n), this.w / 2, this.h / 2);
          
          if (n === 1 && this.countdown < 0.4) {
            this.ctx.font = '800 32px Fredoka, system-ui';
            this.ctx.fillText('Go!', this.w / 2, this.h / 2 + 44);
          }
        }
        
        gameLoop() {
          const now = performance.now();
          const dt = Math.min(32, now - (this.lastTime || now)) / 1000;
          this.lastTime = now;
          
          if (this.loaded) {
            this.update(dt);
            this.draw();
          }
          
          requestAnimationFrame(() => this.gameLoop());
        }
      }
      
      // Initialize game when page loads
      document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const game = new BitcrabRunner(canvas);
        
        // Set current year
        document.getElementById('year').textContent = new Date().getFullYear();
      });
    </script>
  </body>
</html>
